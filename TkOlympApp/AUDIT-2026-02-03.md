# Audit TkOlympApp (.NET MAUI) – 2026-02-03

Cíl: kritický, konkrétní audit aktuálního stavu (UI + aplikační logika + API vrstva). Zaměřeno na architekturu/MVVM, DI, výkon/UI thread, škálovatelnost, data/bezpečnost a testovatelnost.

---

## Shrnutí hlavních problémů

### High priority

1) **MVVM je nekonzistentní (mix MVVM a „page-as-viewmodel“ code-behind)**
- Část aplikace je už MVVM (např. `EventsPage` + `EventsViewModel`), ale velké části UI stále drží business logiku, stav i síťová volání přímo v code-behind.
- Důsledky: slabá testovatelnost, těžká údržba, regresní bugy v lifecycle, nemožnost sdílet logiku, vysoké riziko UI zamrznutí.

2) **DI lifetime chyby (captive dependencies / “transient přilepený na singleton”)**
- (odstraněno / viz aktualizace v repozitáři)

3) **UI/perf anti-patterny: fire-and-forget + ruční tvorba UI prvků bez virtualizace**
- Časté `Dispatcher.Dispatch(async () => ...)` bez awaitu a bez cancellation → zacyklené reloady, paralelní requesty, nepozorované výjimky.
- Ruční generování UI (např. `PeoplePage` staví kartičky přes `PeopleStack.Children.Add`) → bez virtualizace, vysoká zátěž layoutu, jank při scrollu.

4) **API vrstva je obcházena (ViewModel/Pages volají HTTP/GraphQL „napřímo“)**
- `EventsViewModel` používá `IAuthService.Http` a lokální GraphQL DTO místo `IGraphQlClient` / `IEventService`.
- Důsledky: duplikace GraphQL protokolu, nekonzistentní error handling, chybějící retry/timeout/cancellation, těžká změna API kontraktu.

### Medium priority

1) **Error handling je často „ticho“ (swallow) nebo UI-alert v hluboké vrstvě**
- `catch { }` ve ViewModelech bez logu a bez signálu do UI; jinde zase `DisplayAlertAsync` přímo v Page na základě exception message.
- Důsledky: nedetekované chyby v produkci, nekonzistentní UX, obtížné dohledávání root cause.

2) **Chybí systematická cancellation strategie v UI**
- Většina Page-level async operací neběží s `CancellationToken` svázaným na lifecycle stránky (zrušení při navigaci pryč).

3) **Hardcoded stringy a lokalizační díry**
- UI fallbacky typu „Žádné oznámení.“ nejsou v resx.

### Low priority

1) **Kódový styl a konzistence**
- Nekonzistentní používání loggerů (`ILogger<T>` vs `LoggerService.CreateLogger(...)`), duplicita `JsonSerializerOptions`, duplicita GraphQL request/response DTO.

2) **ViewModel závislosti na MAUI typech**
- Např. `Color` ve VM; v MAUI to není zakázané, ale zhoršuje přenositelnost a čistotu domény.

---

## Konkrétní příklady problémů (co je špatně a proč)

### 1) MVVM porušení / logika v code-behind

- `MainPage` používá `BindingContext = this` a nese stav + síťové volání + scheduling notifikací v lifecycle.
  - Problém: UI třída = View + ViewModel + orchestrátor backendu.
  - Viz: `BindingContext = this` na [MainPage.xaml.cs](MainPage.xaml.cs#L40) a fire-and-forget dispatch na [MainPage.xaml.cs](MainPage.xaml.cs#L75).

-- `NoticeboardPage` dispatchuje load v konstruktoru.
  - (odstraněno / opraveno v kódu)

- `PeoplePage` dělá filtr přes rekurzivní znovu-otevření ActionSheetu (dispatcher volá `OnFilterClicked` znovu).
  - Problém: reentrance, závody, snadné “uživatelské DoS” (rychlé klikání → mnoho pending UI operací).
  - Viz: [Pages/PeoplePage.xaml.cs](Pages/PeoplePage.xaml.cs#L166-L190).

### 2) Výkon: ruční layout bez virtualizace

- `PeoplePage` generuje karty ručně do `StackLayout`.
  - Problém: žádná UI virtualizace (na Androidu typicky výrazně horší scroll + GC churn).
  - Viz: [Pages/PeoplePage.xaml.cs](Pages/PeoplePage.xaml.cs#L232).

### 3) DI lifetime mismatch / captive dependencies

- `IUserService` je singleton, přitom závisí na `IGraphQlClient` (typed client).
  - Problém: transient typed client se vytvoří jednou a „přilepí“ k singletonu; změny politik/handlerů a očekávání o fresh instanci se rozbijí.
  - Registrace: [MauiProgram.cs](MauiProgram.cs#L131-L136) (singleton user service) a [MauiProgram.cs](MauiProgram.cs#L96-L105) (AddHttpClient pro `IGraphQlClient`).

### 4) UI thread / async patterns

- `EventChangeCheckWorker` používá `Task.Run(...).Wait()`.
  - Problém: blokování threadu WorkManageru, riziko ANR-like tlaků (i když je to background), zbytečná dvojitá asynchronnost, žádná cancellation.
  - Viz: [Platforms/Android/EventChangeCheckWorker.cs](Platforms/Android/EventChangeCheckWorker.cs#L25-L66).

- `CalendarViewModel` spouští background operace přes `Task.Run` bez navázaného cancellation a bez zachycení výjimky u fire-and-forget.
  - Problém: nepozorované výjimky, práce běží i když user odejde.
  - Viz: build rows [ViewModels/CalendarViewModel.cs](ViewModels/CalendarViewModel.cs#L271) a background fetch [ViewModels/CalendarViewModel.cs](ViewModels/CalendarViewModel.cs#L289).

### 5) API vrstva obcházena (duplicitní GraphQL protokol)

- `EventsViewModel` serializuje GraphQL request/response s vlastními DTO a volá `_authService.Http.PostAsync` přímo.
  - Problém: obchází `IGraphQlClient` (tím pádem obchází jednotný error handling a policies), dělá si vlastní DTO/Options, ignoruje HTTP/GraphQL chyby (return bez signálu).
  - Viz: request build [ViewModels/EventsViewModel.cs](ViewModels/EventsViewModel.cs#L138-L171), přímý HTTP call [ViewModels/EventsViewModel.cs](ViewModels/EventsViewModel.cs#L152), vlastní DTO [ViewModels/EventsViewModel.cs](ViewModels/EventsViewModel.cs#L245-L276).

### 6) Error handling: swallow

- `EventsViewModel` má `catch { }` bez logu.
  - Problém: produkční chyby jsou tiché; uživatel jen vidí prázdno.
  - Viz: [ViewModels/EventsViewModel.cs](ViewModels/EventsViewModel.cs#L207-L223).

---

## Doporučená řešení (s ukázkami)

### A) Zastropovat vrstvy: UI → ViewModel → Services → GraphQlClient

**Problém:** UI/VM obchází servisní vrstvu.

**Směr řešení:**
- ViewModel nemá serializovat GraphQL ani držet `HttpClient`.
- Vytvořit (nebo použít existující) `IEventService.GetCampsAsync(...)` a `IGraphQlClient.PostAsync<T>`.

Ukázka (princip):

```csharp
// ViewModel: pouze orchestrace + state
public partial class EventsViewModel : ViewModelBase
{
    private readonly IEventService _eventService;

    [RelayCommand]
    private async Task RefreshAsync(CancellationToken ct)
    {
        IsBusy = true;
        try
        {
            var camps = await _eventService.GetCampsAsync(rangeStart, rangeEnd, ct);
            // naplnit kolekce
        }
        finally { IsBusy = false; }
    }
}
```

### B) DI lifetimes sjednotit podle charakteru služby

**Problém:** singleton drží transient typed client.

**Směr řešení:** vyber jednu konzistentní variantu:
1) **Stateless service = singleton**, ale pak i HTTP klienty řešit přes `IHttpClientFactory` a nevázat se na transient typed client instance.
2) **Service = transient**, když závisí na typed clientu.

Nejmenší změna v současném modelu: `IUserService` změnit na transient (pokud drží jen “cache” a storage) nebo odstranit runtime state z `UserServiceImplementation`.

### C) Vyhodit `Task.Run(...).Wait()` z Android WorkManager

**Problém:** `.Wait()` + `Task.Run` blokuje a maskuje cancellation.

Ukázka (princip):

```csharp
public override Result DoWork()
{
    try
    {
        DoWorkAsync(CancellationToken.None).GetAwaiter().GetResult();
        return Result.InvokeSuccess()!;
    }
    catch { return Result.InvokeFailure()!; }
}

private async Task DoWorkAsync(CancellationToken ct)
{
    // await bez Task.Run a bez Wait
}
```

Lepší long-term varianta je přejít na WorkManager typ, který podporuje async přímo (podle možností bindingu).

### D) PeoplePage: přestat generovat UI ručně

**Problém:** layout churn, žádná virtualizace.

**Směr řešení:** `CollectionView` s `ItemsSource` (ideálně přes ViewModel), recyklace prvků, filtrování nad daty, ne nad UI prvky.

---

## Rychlé winy (lokální opravy s vysokým přínosem)

 - (Původní doporučení o `Dispatcher.Dispatch` bylo částečně implementováno; konkrétní položky byly z repozitáře odstraněny.)
- Nahradit `.Wait()` v [Platforms/Android/EventChangeCheckWorker.cs](Platforms/Android/EventChangeCheckWorker.cs#L25-L66) za čisté await flow (bez `Task.Run`).
- V `EventsViewModel`:
  - logovat výjimky místo `catch { }` a propagovat error stav do UI (např. `ErrorMessage`),
  - přestat používat `_authService.Http` přímo a volat servis.
- Zlokalizovat hardcoded texty („Žádné oznámení.“ apod.).

---

## Dlouhodobá architektonická zlepšení (co je dnes špatně systémově)

- **Nedokončená MVVM konsolidace**: aplikace je teď hybrid. Výsledkem je, že jsou zavedené ViewModel infrastruktury (`ViewModelBase`, `INavigationService`), ale velké Pages je nevyužívají a nesou logiku samy.
- **Chybí jednotný „API boundary“**: část kódu používá `IGraphQlClient`, část ručně tvoří GraphQL requesty. To brání zlepšování (retry, logging, tracing, caching) na jednom místě.
- **Chybí lifecycle-cancellation standard**: pro každou stránku/VM by měl být jednotný pattern, jak zrušit load při odchodu (a jak zabránit paralelním reloadům).
- **UI výkon je závislý na ručně sestavených layout tree**: bez virtualizace se to nebude dobře škálovat s počtem lidí/řádků.

---

## Co je udělané dobře (aby bylo jasno)

- DI + typed HttpClient a centrální konfigurace base URL + tenant header je správný směr (viz [MauiProgram.cs](MauiProgram.cs#L96-L105)).
- `GraphQlClientImplementation` řeší GraphQL errors konzistentně a používá stream deserializaci (nižší memory pressure).
- `AppShell` má korektní cancellation a `Dispose()` pro polling loop (viz [AppShell.xaml.cs](AppShell.xaml.cs#L260-L303)).
